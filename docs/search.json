[
  {
    "objectID": "posts/example-blog-post/index.html",
    "href": "posts/example-blog-post/index.html",
    "title": "Hello Blog",
    "section": "",
    "text": "from source import Perceptron\np = Perceptron()\n\nI did it!!\nnot implemented\nThis is an example of the blog posts that you’ll submit as your primary form of learning demonstration in CSCI 0451. I created this post by modifying the file posts/example-blog-post/index.ipynb in VSCode. You can also use JupyterLab for this editing if you prefer. Finally, it is possible to write blog posts without using notebooks by writing .qmd files, as illustrated here."
  },
  {
    "objectID": "posts/example-blog-post/index.html#math",
    "href": "posts/example-blog-post/index.html#math",
    "title": "Hello Blog",
    "section": "Math",
    "text": "Math\nIn addition to regular text using the Markdown specification, you can also write mathematics, enclosed between dollar signs. The syntax for writing math is very similar to the syntax used in the \\(\\LaTeX\\) markup language. For example, $f(x) \\approx y$ renders to \\(f(x) \\approx y\\). To place complex mathematical expressions on their own lines, use double dollar signs. For example, the expression\n$$\\mathcal{L}(a, b) = \\sum_{i = 1}^n (ax_i + b - y_i)^2$$\nrenders to:\n\\[\\mathcal{L}(a, b) = \\sum_{i = 1}^n (ax_i + b - y_i)^2\\;.\\]\nBehind the scenes, math is powered by the MathJax engine. For more on how to write math, check this handy tutorial and quick reference."
  },
  {
    "objectID": "posts/new-test-post/index.html",
    "href": "posts/new-test-post/index.html",
    "title": "Second Post",
    "section": "",
    "text": "from source import Perceptron\np = Perceptron()\n\nI did it!!\nnot implemented\nThis is an example of the blog posts that you’ll submit as your primary form of learning demonstration in CSCI 0451. I created this post by modifying the file posts/example-blog-post/index.ipynb in VSCode. You can also use JupyterLab for this editing if you prefer. Finally, it is possible to write blog posts without using notebooks by writing .qmd files, as illustrated here."
  },
  {
    "objectID": "posts/new-test-post/index.html#math",
    "href": "posts/new-test-post/index.html#math",
    "title": "Second Post",
    "section": "Math",
    "text": "Math\nIn addition to regular text using the Markdown specification, you can also write mathematics, enclosed between dollar signs. The syntax for writing math is very similar to the syntax used in the \\(\\LaTeX\\) markup language. For example, $f(x) \\approx y$ renders to \\(f(x) \\approx y\\). To place complex mathematical expressions on their own lines, use double dollar signs. For example, the expression\n$$\\mathcal{L}(a, b) = \\sum_{i = 1}^n (ax_i + b - y_i)^2$$\nrenders to:\n\\[\\mathcal{L}(a, b) = \\sum_{i = 1}^n (ax_i + b - y_i)^2\\;.\\]\nBehind the scenes, math is powered by the MathJax engine. For more on how to write math, check this handy tutorial and quick reference."
  },
  {
    "objectID": "index.html",
    "href": "index.html",
    "title": "My Awesome CSCI 0451 Blog",
    "section": "",
    "text": "Experiments\n\n\n\n\n\n\n\n\n\n\n \n\n\n\n\n  \n\n\n\n\nIllustration\n\n\n\n\n\n\n\n\n\n\n \n\n\n\n\n  \n\n\n\n\nPalmer Penguins\n\n\n\n\n\n\n\n\n\n\n \n\n\n\n\n  \n\n\n\n\nAuditing Allocative Bias\n\n\n\n\n\n\n\n\n\n\n \n\n\n\n\n  \n\n\n\n\nPerceptron\n\n\n\n\n\n\n\n\n\n\n \n\n\n\n\n  \n\n\n\n\nLearning from Timnit Gebru (Parts 1 and 2)\n\n\n\n\n\n\n\n\n\n\n \n\n\n\n\n  \n\n\n\n\nSecond Post\n\n\n\n\n\nA new blog post that I just made!\n\n\n\n\n\n\nMar 10, 2023\n\n\nPhil Chodrow\n\n\n\n\n\n\n  \n\n\n\n\nHello Blog\n\n\n\n\n\nAn example blog post illustrating the key techniques you’ll need to demonstrate your learning in CSCI 0451.\n\n\n\n\n\n\nJan 10, 2023\n\n\nPhil Chodrow\n\n\n\n\n\n\nNo matching items"
  },
  {
    "objectID": "about.html",
    "href": "about.html",
    "title": "About",
    "section": "",
    "text": "About this blog"
  },
  {
    "objectID": "posts/blog-1/blog1.html",
    "href": "posts/blog-1/blog1.html",
    "title": "Perceptron",
    "section": "",
    "text": "Here is the link to the python file: https://github.com/pwad1/465_blog1/blob/main/perceptron.py"
  },
  {
    "objectID": "posts/blog-timnit-gebru/TimnitGebru.html",
    "href": "posts/blog-timnit-gebru/TimnitGebru.html",
    "title": "Learning from Timnit Gebru (Parts 1 and 2)",
    "section": "",
    "text": "Dr. Timnit Gebru is a computer scientist best known for her substantial work on AI ethics and algorithmic bias. She has also done substantial work on computer vision and natural language processing. She is best known for her research highlighting the biases and limitations of facial recognition technology.\nShe had co-founded the Ethical AI team at Google in 2018. In 2020, her work with Google came to an end due to a dispute regarding a paper on the limitations and biases of natural language processing models co-authored by her. Dr. Gebru claims that her paper was not accepted by Google’s journal due to it not taking AI ethics seriously. Her alleged removal from Google was widely reported in the media as an example of large technology companies silencing voices expressing concern about the nature of their operations."
  },
  {
    "objectID": "posts/blog-timnit-gebru/TimnitGebru.html#introduction",
    "href": "posts/blog-timnit-gebru/TimnitGebru.html#introduction",
    "title": "Learning from Timnit Gebru (Parts 1 and 2)",
    "section": "",
    "text": "Dr. Timnit Gebru is a computer scientist best known for her substantial work on AI ethics and algorithmic bias. She has also done substantial work on computer vision and natural language processing. She is best known for her research highlighting the biases and limitations of facial recognition technology.\nShe had co-founded the Ethical AI team at Google in 2018. In 2020, her work with Google came to an end due to a dispute regarding a paper on the limitations and biases of natural language processing models co-authored by her. Dr. Gebru claims that her paper was not accepted by Google’s journal due to it not taking AI ethics seriously. Her alleged removal from Google was widely reported in the media as an example of large technology companies silencing voices expressing concern about the nature of their operations."
  },
  {
    "objectID": "posts/blog-timnit-gebru/TimnitGebru.html#notes-from-the-lecture",
    "href": "posts/blog-timnit-gebru/TimnitGebru.html#notes-from-the-lecture",
    "title": "Learning from Timnit Gebru (Parts 1 and 2)",
    "section": "Notes from the lecture",
    "text": "Notes from the lecture\nDr. Gebru is particularly concerned about how facial recognition tools are used, and how they could be used, by law enforcement agencies. Firstly, facial recognition models face data related constraints, especially among racial and ethnic minorities, and individuals that are non cisgender men. These constrains can result in poorer recognition of these minorities, putting these individuals at greater risk of being interrogated or imprisoned without cause. These tools are also less effective in recognizing cultural differences in non-white cultures, due to biases in data.\nShe also argues that the practices used by law enforcement agencies to collect data for these purposes is highly suspect. States, such as Maryland, use extensive level surveillance programs. Law enforcement agencies have also scraped social media sites to find pictures of individuals participating in certain political activities, and have used their facial recognition models to identify these individuals. According to Dr. Gebru, these practices stifle political dissent and limit personal freedom.\nAdditionally, facial recognition tools might not be used by law enforcement agencies in the ways in which these tools were intended to be used. Hence, biases that are rampant in these institutions could be magnified by these technologies. These tools can also be used by authoritarian regimes to maintain control and establish a police state.\nTl;dr: computer vision technologies are expected to magnify biases that already exist within our societies. To prevent this from happening, we need to be more conscious about how diverse our data is, and how are data is being collected. We also need to be conscious about biases within our models and have a sense of who it is benefiting and who it harming."
  },
  {
    "objectID": "posts/blog-timnit-gebru/TimnitGebru.html#proposed-question",
    "href": "posts/blog-timnit-gebru/TimnitGebru.html#proposed-question",
    "title": "Learning from Timnit Gebru (Parts 1 and 2)",
    "section": "Proposed Question:",
    "text": "Proposed Question:\nThe advancement of computer vision and natural langauge processing models has some obvious benefits and drawbacks. Dr. Gebru’s work does a great job in identifying and studying manners in these models may magnify systemic biases experienced by racial minorities and individuals that are not cisgender men. She is also very convincing in her arguments about how authoritarian regimes may misuse these technologies. However, just as building a model may put certain people at risk, not building a model may also prevent a group of people from realizing certain benefits. How do we assess the opportunity cost of unrealized benefits with the risks posed by machine learning models within the context of ML-related regulation?"
  },
  {
    "objectID": "posts/blog-timnit-gebru/TimnitGebru.html#reflection-on-dr.-gebrus-class-discussion",
    "href": "posts/blog-timnit-gebru/TimnitGebru.html#reflection-on-dr.-gebrus-class-discussion",
    "title": "Learning from Timnit Gebru (Parts 1 and 2)",
    "section": "Reflection on Dr. Gebru’s class discussion",
    "text": "Reflection on Dr. Gebru’s class discussion\nI agree with Dr. Gebru’s idea that funding for ML-related research needs to be more diversified. When most of the funding comes from the government and private corporations with certain vested interests, it is inevitable that these interests, which prioritize what is beneficial at the short term over what is beneficial over the long term.\nHowever, I am not sure if I am as pessimistic about the future of ML as Dr Gebru. In our conversation, it seemed as though Dr. Gebru was discounting the benefits that ML has brought, and can bring, to vulnerable communities.\nI really enjoyed Xianzhi’s question about the construction of an alternative reality in which everything computer vision can be rebuilt in a manner that is beneficial for society at large in the long term. I found it somewhat surprising that, according to Dr. Gebru, in an ideal society, computer vision should not exist. It felt as though Professor Gebru was ignoring some of positive effects of computer vision. For example, it results in improved medical diagnostics and helps make the internet more accesible. Dr. Gebru, due to her years of experience in this field, may have a greater degree of pessimism associated with the effects of machine learning that might be unfathomable to me.\nI was also slightly disappointed by her response to my question. My question focused on the weighing the opportunity costs associated with putting restrictions on AI research. The idea behind this question is that while the research and applications of machine learning technologies are doing a lot of bad in the world, they are also doing a lot of good. In my opinion, good that is prevented from happening is equivalent to something bad being done. I was expecting an answer that weighed the bad done by ML against the good. However, I do not think that her response to my question did this. I think that she made an argument related to path dependency which somewhat satisfied me."
  },
  {
    "objectID": "posts/blog-timnit-gebru/TimnitGebru.html#dr.-gebrus-presentation-at-hillcrest",
    "href": "posts/blog-timnit-gebru/TimnitGebru.html#dr.-gebrus-presentation-at-hillcrest",
    "title": "Learning from Timnit Gebru (Parts 1 and 2)",
    "section": "Dr. Gebru’s presentation at Hillcrest",
    "text": "Dr. Gebru’s presentation at Hillcrest\nDr. Gebru’s discussed several intellectual movements- denoted by the umbrella term TESCREAL- that are currently involved in the study of AI ethics and AI risk minization, and argued that these movements are tied to eugenics. She suggested that some of the personalities, such as Eliezer Yudkowsky, involved in these movements are racist, problematic and poorly equipped to handle this topic. She also argues that the God Complex harbored by some in this field is problematic. She also discussed her disdain for the term “AGI.” She argued that this term is extremely vague and that it has effectively become a buzzword for companies such as OpenAI. She also expressed her disdain for for certain tech-evangelists, like Sam Altman who believe that machine learning will change the world for the better. She touched upon the problematic history of statistics, and how it was tied in with the development of Eugenics. In fact, Galton, a pioneering figure in modern statistics, is also one of the foremeost figures in the Eugenics movement."
  },
  {
    "objectID": "posts/blog-timnit-gebru/TimnitGebru.html#reflection-on-dr.-gebrus-presentation-at-hillcrest",
    "href": "posts/blog-timnit-gebru/TimnitGebru.html#reflection-on-dr.-gebrus-presentation-at-hillcrest",
    "title": "Learning from Timnit Gebru (Parts 1 and 2)",
    "section": "Reflection on Dr. Gebru’s presentation at Hillcrest",
    "text": "Reflection on Dr. Gebru’s presentation at Hillcrest\nI was really looking forward to Dr. Gebru’s talk- I really enjoyed the lecture Dr. Chodrow had posted to on the assignments page- and am also familiar with some of her other work. I’ve enjoyed listening to her one of my favorite podcasts- In Machines We Trust- and really liked her paper on stochastic parrots. I was, however, somewhat disappointed by her talk. I am familiar with the ideas espoused by Effective Altruism. I do not agree with these ideas. I think that Effective Altruism’s mission is deeply flawed- the idea that a select few wealthy individuals should leverege their wealth to change the world in a manner that they deem fit is undemocratic and dangerous. I also believe that this movement is used by corporations, such as FTX, to put on a facade of doing good whilst obscuring their unethical deeds. However, I think that it is a stretch to dub this movement to be eugenicist.\nI am not too familiar with the other movements she mentioned- such as transhumanism, extropianism and singulartarianism- however I do not think that she effectively showed how any of the TESCREAL movements are definitionally eugenics. I think that the question that Tim asked in the question and answer session was particularly important. It is important to define what eugenics is to show that certain movements are eugenicist. Her response to that- which was a version of “go read a book”- felt inappropriate. An earnest answer to that question was central to the discussion- and hence there was value lost in this interaction.\nIt also felt as though she was cherry picking quotes from cherry picked figures in these movements- and she used sweeping generalizations to argue that these movements are eugenicist. Overall, I was a little disappointed in the lack of nuance in her argument. This could be a result of time constraints. I was really looking forward to this session with Dr. Gebru, am a little disheartened by how it turned out."
  },
  {
    "objectID": "posts/blog-1/blog1.html#experiment-1",
    "href": "posts/blog-1/blog1.html#experiment-1",
    "title": "Perceptron",
    "section": "Experiment 1",
    "text": "Experiment 1\nUsing 2d data like the data in the example, if the data is linearly separable then the perceptron algorithm converges to weight vector w describing a separating line (provided that the maximum number of iterations is large enough).\nPlease show visualizations of the data, the separating line, and the evolution of the accuracy over training. It’s also fine for you to use the loss instead of the accuracy if you’d prefer.\n(The two visualizations above show the data with the line of separation and the evolution of the accuracy over time)\nAs we can observe in the first chart, the data is linearly separable, and the line of separation, as produced by the Perceptron, separates the two colors.\nThe second chart indicates the accuracy for the perceptron, based on the proportion of points classified correctly, by the number of iterations.\n\nimport numpy as np\nimport pandas as pd\nimport seaborn as sns\nfrom matplotlib import pyplot as plt\nfrom sklearn.datasets import make_blobs\n\nfrom perceptron import Perceptron\n\nnp.random.seed(12345)\n\nn = 100\np_features = 3\n\nX, y = make_blobs(n_samples = 100, n_features = p_features - 1, centers = [(-1.7, -1.7), (1.7, 1.7)])\n\np = Perceptron()\np.fit(X, y, max_steps=1000)\np.w\nprint(p.history[-10:])\n\nw= np.array([1, 2, 3, 4, 5])\nx= np.array([2, 2, 3, 4, 5])\nb= 1000\n\n\ndef draw_line(w, x_min, x_max):\n  x = np.linspace(x_min, x_max, 101)\n  y = -(w[0]*x + w[2])/w[1]\n  plt.plot(x, y, color = \"black\")\n\nfig = plt.scatter(X[:,0], X[:,1], c = y)\nfig = draw_line(p.w, -2, 2)\n\nxlab = plt.xlabel(\"Feature 1\")\nylab = plt.ylabel(\"Feature 2\")\n\n#print(Perceptron.perceptron_classify(w, b ,x))\n\n#print(Perceptron.fit(w,x))\n\n[0.97, 0.97, 0.97, 0.97, 0.97, 0.97, 0.97, 0.97, 0.97, 1.0]\n\n\n\n\n\n\nfig = plt.plot(p.history)\nxlab = plt.xlabel(\"Iteration\")\nylab = plt.ylabel(\"Accuracy\")"
  },
  {
    "objectID": "posts/blog-1/blog1.html#experiment-2",
    "href": "posts/blog-1/blog1.html#experiment-2",
    "title": "Perceptron",
    "section": "Experiment 2",
    "text": "Experiment 2\nFor 2d data, when the data is not linearly separable, the perceptron algorithm will not settle on a final value of w, but will instead run until the maximum number of iterations is reached, without achieving perfect accuracy.\nPlease show visualizations of the data, the line in the final iteration, and the evolution of the score over training.\n\nimport numpy as np\nimport pandas as pd\nimport seaborn as sns\nfrom matplotlib import pyplot as plt\nfrom sklearn.datasets import make_blobs\n\nfrom perceptron import Perceptron\n\nnp.random.seed(12345)\n\nn = 100\np_features = 3\n\nX, y = make_blobs(n_samples = 100, n_features = p_features - 1, centers =  [(0, 0), (0, 0)])\n\np = Perceptron()\np.fit(X, y, max_steps=1000)\np.w\nprint(p.history[-10:])\n\nw= np.array([1, 2, 3, 4, 5])\nx= np.array([2, 2, 3, 4, 5])\nb= 1000\n\n\ndef draw_line(w, x_min, x_max):\n  x = np.linspace(x_min, x_max, 101)\n  y = -(w[0]*x + w[2])/w[1]\n  plt.plot(x, y, color = \"black\")\n\nfig = plt.scatter(X[:,0], X[:,1], c = y)\nfig = draw_line(p.w, -2, 2)\n\nxlab = plt.xlabel(\"Feature 1\")\nylab = plt.ylabel(\"Feature 2\")\n\n[0.52, 0.54, 0.45, 0.48, 0.48, 0.41, 0.47, 0.48, 0.48, 0.48]\n\n\n\n\n\n\nfig = plt.plot(p.history)\nxlab = plt.xlabel(\"Iteration\")\nylab = plt.ylabel(\"Accuracy\")\n\n\n\n\nThe perceptron algorithm is also able to work in more than 2 dimensions! Show an example of running your algorithm on data with at least 5 features. You don’t need to visualize the data or the separating line, but you should still show the evolution of the score over the training period. Include a comment on whether you believe that the data is linearly separable based on your observation of the score.\n\nimport numpy as np\nimport pandas as pd\nimport seaborn as sns\nfrom matplotlib import pyplot as plt\nfrom sklearn.datasets import make_blobs\n\nfrom perceptron import Perceptron\n\nnp.random.seed(12345)\n\nn = 100\np_features = 5\n\nX, y = make_blobs(n_samples = 100, n_features = p_features - 1, centers = [(8, 8), (-8, -8), (0, 0), (4, 4)])\n\np = Perceptron()\np.fit(X, y, max_steps=50000)\np.w\nprint(p.history[-10:])\n\nw= np.array([1, 2, 3, 4, 5])\nx= np.array([2, 2, 3, 4, 5])\nb= 1000\n\n[0.5, 0.5, 0.5, 0.5, 0.5, 0.5, 0.5, 0.5, 0.5, 0.5]\n\n\nHere is the link to the python file: https://github.com/pwad1/465_blog1/blob/main/perceptron.py"
  },
  {
    "objectID": "posts/blog-2/GradientDescent.html",
    "href": "posts/blog-2/GradientDescent.html",
    "title": "Illustration",
    "section": "",
    "text": "from solutions import LogisticRegression # your source code\nfrom sklearn.datasets import make_blobs\nfrom matplotlib import pyplot as plt\nimport numpy as np\nnp.seterr(all='ignore') \n\n# make the data\np_features = 3\nX, y = make_blobs(n_samples = 200, n_features = p_features - 1, centers = [(-1, -1), (1, 1)])\n\nfig = plt.scatter(X[:,0], X[:,1], c = y)\nxlab = plt.xlabel(\"Feature 1\")\nylab = plt.ylabel(\"Feature 2\")\n\n\n\n\n\nLR = LogisticRegression()\nLR.fit(X, y, alpha = 0.1, max_epochs = 1000)\n\nLR.fit_stochastic(X, y, max_epochs = 1000, batch_size=10, alpha=0.1)\n\ndef draw_line(w, x_min, x_max):\n  x = np.linspace(x_min, x_max, 101)\n  y = -(w[0]*x + w[2])/w[1]\n  plt.plot(x, y, color = \"black\")\n\n# inspect the fitted value of w\nLR.w \nprint(LR.w)\nfig = plt.scatter(X[:,0], X[:,1], c = y)\nxlab = plt.xlabel(\"Feature 1\")\nylab = plt.ylabel(\"Feature 2\")\nfig = draw_line(LR.w, -2, 2)\n\n[ 1.47117134  1.46657887 -0.057082  ]\n\n\n\n\n\n\nnum_steps = len(LR.loss_history)\nplt.plot(np.arange(num_steps) + 1, LR.loss_history, label = \"gradient\")\n\nnum_steps = len(LR.loss_history_st)\nplt.plot(np.arange(num_steps) + 1, LR.loss_history_st, label = \"stochastic gradient\")\n\nplt.loglog()\n\nlegend = plt.legend() \nxlab = plt.xlabel(\"Number of iterations\")\nylab = plt.ylabel(\"Loss\")\n\n\n\n\nIn the above plot, we can see that the curve representing stoachastic converges to the minimum loss much faster than the curve representing the gradient. This suggests that our algorithm for stochastic descent is significantly more efficient.\n\nExperiments\n\nA case in which gradient descent does not converge to a minimizer because the learning rate is too large.\n\nLR_e1 = LogisticRegression()\nLR_e1.fit(X, y, alpha = 100, max_epochs = 1000)\n\n\n# inspect the fitted value of w\nLR_e1.w \nprint(LR_e1.w)\nfig2 = plt.scatter(X[:,0], X[:,1], c = y)\nxlab = plt.xlabel(\"Feature 1\")\nylab = plt.ylabel(\"Feature 2\")\n\nfig2 = draw_line(LR_e1.w, -2, 2)\n\n[ 29.9437262   24.67590194 -10.61155879]\n\n\n\n\n\n\nnum_steps = len(LR_e1.loss_history)\nplt.plot(np.arange(num_steps) + 1, LR_e1.loss_history, label = \"gradient\")\n\nplt.loglog()\n\nlegend = plt.legend() \nxlab = plt.xlabel(\"Number of iterations\")\nylab = plt.ylabel(\"Loss\")\n\n\n\n\nAs the above loss history chart shows, with a sufficiently high learning rate, which, in our case is 100, our algorithm is no longer able to converge to the minimum loss. A converging loss function would always have a negative slope. The curve (curves?) above have positive as well as negative slopes, suggesting that the loss decreases and increrases with increasing iterations.\n\n\nA case in which the choice of batch size influences how quickly the algorithm converges.\n\nLR_e2i = LogisticRegression()\nLR_e2ii = LogisticRegression()\nLR_e2iii = LogisticRegression()\nLR_e2iv = LogisticRegression()\nLR_e2v = LogisticRegression()\nLR_e2vi = LogisticRegression()\nLR_e2vii = LogisticRegression()\n\n\nLR_e2i.fit_stochastic(X, y, max_epochs = 1000, batch_size=2, alpha=0.1)\nLR_e2ii.fit_stochastic(X, y, max_epochs = 1000, batch_size=3, alpha=0.1)\nLR_e2iii.fit_stochastic(X, y, max_epochs = 1000, batch_size=5, alpha=0.1)\nLR_e2iv.fit_stochastic(X, y, max_epochs = 1000, batch_size=10, alpha=0.1)\nLR_e2v.fit_stochastic(X, y, max_epochs = 1000, batch_size=20, alpha=0.1)\nLR_e2vi.fit_stochastic(X, y, max_epochs = 1000, batch_size=40, alpha=0.1)\nLR_e2vii.fit_stochastic(X, y, max_epochs = 1000, batch_size=80, alpha=0.1)\n\n# inspect the fitted value of w\nLR_e2i.w \nfig = plt.scatter(X[:,0], X[:,1], c = y)\nxlab = plt.xlabel(\"Feature 1\")\nylab = plt.ylabel(\"Feature 2\")\n\n\n\n\n\nnum_steps = len(LR_e2vii.loss_history_st)\nplt.plot(np.arange(num_steps) + 1, LR_e2vii.loss_history_st, label = \"batch size=80\")\n\nnum_steps = len(LR_e2vi.loss_history_st)\nplt.plot(np.arange(num_steps) + 1, LR_e2vi.loss_history_st, label = \"batch size=40\")\n\nnum_steps = len(LR_e2v.loss_history_st)\nplt.plot(np.arange(num_steps) + 1, LR_e2v.loss_history_st, label = \"batch size=20\")\n\nnum_steps = len(LR_e2iv.loss_history_st)\nplt.plot(np.arange(num_steps) + 1, LR_e2iv.loss_history_st, label = \"batch size=10\")\n\nnum_steps = len(LR_e2iii.loss_history_st)\nplt.plot(np.arange(num_steps) + 1, LR_e2iii.loss_history_st, label = \"batch size=5\")\n\nnum_steps = len(LR_e2ii.loss_history_st)\nplt.plot(np.arange(num_steps) + 1, LR_e2ii.loss_history_st, label = \"batch size=3\")\n\nnum_steps = len(LR_e2i.loss_history_st)\nplt.plot(np.arange(num_steps) + 1, LR_e2i.loss_history_st, label = \"batch size=2\")\n\nplt.loglog()\n\nlegend = plt.legend() \n\n\n\n\nWe observe a significant difference in the loss history for different batch sizes. We can see that smaller batch sizes tend to result in convergence to the minimum loss at a faster rate. However, for extremely small batch sizes, such as batch sizes of 2 or 3, the convergence is not completely uniform.\n\n\nA case in which gradient descent does not converge to a minimizer because the learning rate is too large. In at least one of these experiments, generate some synthetic data (it’s fine to use make_blobs) for data of at least 10 feature dimensions.\n\np_features = 10\nX, y = make_blobs(n_samples = 200, n_features = p_features - 1, centers = [(-1, -1), (1, 1)])\n\nfig = plt.scatter(X[:,0], X[:,1], c = y)\nxlab = plt.xlabel(\"Feature 1\")\nylab = plt.ylabel(\"Feature 2\")\n\nLR = LogisticRegression()\nLR.fit(X, y, alpha = 0.1, max_epochs = 1000)\n\nLR2= LogisticRegression()\nLR2.fit(X, y, alpha = 100, max_epochs = 1000)\n\n\n\n\n\nnum_steps = len(LR.loss_history)\nplt.plot(np.arange(num_steps) + 1, LR.loss_history, label = \"LR=0.1\")\nplt.plot(np.arange(num_steps) + 1, LR2.loss_history, label = \"LR=100\")\n#plt.loglog()\n\nlegend = plt.legend() \n\n\n\n\nAs we can observe, our inference about the impact of a sufficiently high learning rate also holds true for examples with 10 features. The blue curve, representing a learning rate of 0.1 uniformly converges to the minimum loss for our regression. The orange curve does not converge to any value, and fluctuates with increasing and decreasing loss values for all iterations."
  },
  {
    "objectID": "posts/blog-2/GradientDescent.html#illustration",
    "href": "posts/blog-2/GradientDescent.html#illustration",
    "title": "Optimization for Logistic Regression",
    "section": "Illustration",
    "text": "Illustration\n\nnum_steps = len(LR.loss_history)\nplt.plot(np.arange(num_steps) + 1, LR.loss_history, label = \"gradient\")\n\nnum_steps = len(LR.loss_history_st)\nplt.plot(np.arange(num_steps) + 1, LR.loss_history_st, label = \"stochastic gradient\")\n\nplt.loglog()\n\nlegend = plt.legend()"
  },
  {
    "objectID": "posts/blog-3/blog3.html",
    "href": "posts/blog-3/blog3.html",
    "title": "Palmer Penguins",
    "section": "",
    "text": "Here is the link to the python file:\nimport pandas as pd\nimport seaborn as sns\nimport matplotlib.pyplot as plt\nimport numpy as np\n\ntrain_url = \"https://raw.githubusercontent.com/middlebury-csci-0451/CSCI-0451/main/data/palmer-penguins/train.csv\"\ntrain = pd.read_csv(train_url)\ntrain.head()\n\n\n\n\n\n\n\n\nstudyName\nSample Number\nSpecies\nRegion\nIsland\nStage\nIndividual ID\nClutch Completion\nDate Egg\nCulmen Length (mm)\nCulmen Depth (mm)\nFlipper Length (mm)\nBody Mass (g)\nSex\nDelta 15 N (o/oo)\nDelta 13 C (o/oo)\nComments\n\n\n\n\n0\nPAL0708\n27\nGentoo penguin (Pygoscelis papua)\nAnvers\nBiscoe\nAdult, 1 Egg Stage\nN46A1\nYes\n11/29/07\n44.5\n14.3\n216.0\n4100.0\nNaN\n7.96621\n-25.69327\nNaN\n\n\n1\nPAL0708\n22\nGentoo penguin (Pygoscelis papua)\nAnvers\nBiscoe\nAdult, 1 Egg Stage\nN41A2\nYes\n11/27/07\n45.1\n14.5\n215.0\n5000.0\nFEMALE\n7.63220\n-25.46569\nNaN\n\n\n2\nPAL0910\n124\nAdelie Penguin (Pygoscelis adeliae)\nAnvers\nTorgersen\nAdult, 1 Egg Stage\nN67A2\nYes\n11/16/09\n41.4\n18.5\n202.0\n3875.0\nMALE\n9.59462\n-25.42621\nNaN\n\n\n3\nPAL0910\n146\nAdelie Penguin (Pygoscelis adeliae)\nAnvers\nDream\nAdult, 1 Egg Stage\nN82A2\nYes\n11/16/09\n39.0\n18.7\n185.0\n3650.0\nMALE\n9.22033\n-26.03442\nNaN\n\n\n4\nPAL0708\n24\nChinstrap penguin (Pygoscelis antarctica)\nAnvers\nDream\nAdult, 1 Egg Stage\nN85A2\nNo\n11/28/07\n50.6\n19.4\n193.0\n3800.0\nMALE\n9.28153\n-24.97134\nNaN\nfrom sklearn.preprocessing import LabelEncoder\nle = LabelEncoder()\nle.fit(train[\"Species\"])\n\ndef prepare_data(df):\n  df = df.drop([\"studyName\", \"Sample Number\", \"Individual ID\", \"Date Egg\", \"Comments\", \"Region\"], axis = 1)\n  df = df[df[\"Sex\"] != \".\"]\n  df = df.dropna()\n  y = le.transform(df[\"Species\"])\n  df = df.drop([\"Species\"], axis = 1)\n  df = pd.get_dummies(df)\n  return df, y\n\nX_train, y_train = prepare_data(train)\n\nX_train.head()\n\n\n\n\n\n\n\n\nCulmen Length (mm)\nCulmen Depth (mm)\nFlipper Length (mm)\nBody Mass (g)\nDelta 15 N (o/oo)\nDelta 13 C (o/oo)\nIsland_Biscoe\nIsland_Dream\nIsland_Torgersen\nStage_Adult, 1 Egg Stage\nClutch Completion_No\nClutch Completion_Yes\nSex_FEMALE\nSex_MALE\n\n\n\n\n1\n45.1\n14.5\n215.0\n5000.0\n7.63220\n-25.46569\n1\n0\n0\n1\n0\n1\n1\n0\n\n\n2\n41.4\n18.5\n202.0\n3875.0\n9.59462\n-25.42621\n0\n0\n1\n1\n0\n1\n0\n1\n\n\n3\n39.0\n18.7\n185.0\n3650.0\n9.22033\n-26.03442\n0\n1\n0\n1\n0\n1\n0\n1\n\n\n4\n50.6\n19.4\n193.0\n3800.0\n9.28153\n-24.97134\n0\n1\n0\n1\n1\n0\n0\n1\n\n\n5\n33.1\n16.1\n178.0\n2900.0\n9.04218\n-26.15775\n0\n1\n0\n1\n0\n1\n1\n0"
  },
  {
    "objectID": "posts/blog-3/blog3.html#feature-selection",
    "href": "posts/blog-3/blog3.html#feature-selection",
    "title": "Palmer Penguins",
    "section": "Feature selection",
    "text": "Feature selection\n\nimport warnings\n\nwarnings.filterwarnings(\"ignore\") #I got a whole load of warnings making my notebook look ugly.\n\nfrom itertools import combinations\nfrom sklearn.linear_model import LogisticRegression\n# these are not actually all the columns: you'll \n# need to add any of the other ones you want to search for\nall_qual_cols = [\"Clutch Completion\", \"Sex\", \"Island\", \"Island\", \"Island\"]\nall_quant_cols = ['Culmen Length (mm)', 'Culmen Depth (mm)', 'Flipper Length (mm)', \"Body Mass (g)\", \"Delta 15 N (o/oo)\",\"Delta 13 C (o/oo)\"]\n\nfor qual in all_qual_cols: \n  qual_cols = [col for col in X_train.columns if qual in col ]\n  for pair in combinations(all_quant_cols, 2):\n    cols = qual_cols + list(pair)\n    LR = LogisticRegression()\n    LR.fit(X_train[cols], y_train)\n    score=LR.score(X_train[cols], y_train)\n    if score==1:\n        print(cols, score)\n    # you could train models and score them here, keeping the list of \n    # columns for the model that has the best score. \n\n['Island_Biscoe', 'Island_Dream', 'Island_Torgersen', 'Culmen Length (mm)', 'Culmen Depth (mm)'] 1.0\n['Island_Biscoe', 'Island_Dream', 'Island_Torgersen', 'Culmen Length (mm)', 'Culmen Depth (mm)'] 1.0\n['Island_Biscoe', 'Island_Dream', 'Island_Torgersen', 'Culmen Length (mm)', 'Culmen Depth (mm)'] 1.0\n\n\nIt looks like we have three combinations giving us 100% accuracy! Let’s test one of them again.\n\nfrom sklearn.linear_model import LogisticRegression\n\n# this counts as 3 features because the two Clutch Completion \n# columns are transformations of a single original measurement. \n# you should find a way to automatically select some better columns\n# as suggested in the code block above\ncols = ['Culmen Length (mm)', 'Culmen Depth (mm)', 'Island_Biscoe', 'Island_Dream', 'Island_Torgersen']\n\nLR1 = LogisticRegression()\nLR1.fit(X_train[cols], y_train)\nscore=LR1.score(X_train[cols], y_train)\nprint(score)\n\nwarnings.resetwarnings() #warnings are still useful! I am reactivating warnings.\n\n1.0\n\n\n/Users/prateekwadhavkar/opt/anaconda3/lib/python3.9/site-packages/sklearn/linear_model/_logistic.py:814: ConvergenceWarning: lbfgs failed to converge (status=1):\nSTOP: TOTAL NO. of ITERATIONS REACHED LIMIT.\n\nIncrease the number of iterations (max_iter) or scale the data as shown in:\n    https://scikit-learn.org/stable/modules/preprocessing.html\nPlease also refer to the documentation for alternative solver options:\n    https://scikit-learn.org/stable/modules/linear_model.html#logistic-regression\n  n_iter_i = _check_optimize_result(\n\n\nLet us now test our findings:\n\ntest_url = \"https://raw.githubusercontent.com/middlebury-csci-0451/CSCI-0451/main/data/palmer-penguins/test.csv\"\ntest = pd.read_csv(test_url)\n\nX_test, y_test = prepare_data(test)\nLR.score(X_test[cols], y_test)\n\n1.0\n\n\n\nfrom matplotlib import pyplot as plt\nimport numpy as np\n\n\nX_train[cols]\n\n\n\n\n\n\n\n\nIsland_Biscoe\nIsland_Dream\nIsland_Torgersen\nCulmen Length (mm)\nCulmen Depth (mm)\n\n\n\n\n1\n1\n0\n0\n45.1\n14.5\n\n\n2\n0\n0\n1\n41.4\n18.5\n\n\n3\n0\n1\n0\n39.0\n18.7\n\n\n4\n0\n1\n0\n50.6\n19.4\n\n\n5\n0\n1\n0\n33.1\n16.1\n\n\n...\n...\n...\n...\n...\n...\n\n\n269\n0\n1\n0\n41.1\n17.5\n\n\n270\n1\n0\n0\n45.4\n14.6\n\n\n271\n0\n0\n1\n36.2\n17.2\n\n\n272\n1\n0\n0\n50.0\n15.9\n\n\n273\n1\n0\n0\n48.2\n14.3\n\n\n\n\n256 rows × 5 columns\n\n\n\n\nLR1\n\nLogisticRegression()\n\n\n\nfrom matplotlib.patches import Patch\n\ndef plot_regions(model, X, y):\n    \n    x0 = X[X.columns[0]]\n    x1 = X[X.columns[1]]\n    qual_features = X.columns[2:]\n    \n    fig, axarr = plt.subplots(1, len(qual_features), figsize = (7, 3))\n\n    # create a grid\n    grid_x = np.linspace(x0.min(),x0.max(),501)\n    grid_y = np.linspace(x1.min(),x1.max(),501)\n    xx, yy = np.meshgrid(grid_x, grid_y)\n    \n    XX = xx.ravel()\n    YY = yy.ravel()\n\n    for i in range(len(qual_features)):\n      XY = pd.DataFrame({\n          X.columns[0] : XX,\n          X.columns[1] : YY\n      })\n\n      for j in qual_features:\n        XY[j] = 0\n\n      XY[qual_features[i]] = 1\n\n      p = model.predict(XY)\n      p = p.reshape(xx.shape)\n      \n      \n      # use contour plot to visualize the predictions\n      axarr[i].contourf(xx, yy, p, cmap = \"jet\", alpha = 0.2, vmin = 0, vmax = 2)\n      \n      ix = X[qual_features[i]] == 1\n      # plot the data\n      axarr[i].scatter(x0[ix], x1[ix], c = y[ix], cmap = \"jet\", vmin = 0, vmax = 2)\n      \n      axarr[i].set(xlabel = X.columns[0], \n            ylabel  = X.columns[1])\n      \n      patches = []\n      for color, spec in zip([\"red\", \"green\", \"blue\"], [\"Adelie\", \"Chinstrap\", \"Gentoo\"]):\n        patches.append(Patch(color = color, label = spec))\n\n      plt.legend(title = \"Species\", handles = patches, loc = \"best\")\n      \n      plt.tight_layout()\n\n\nprint()\nplot_regions(LR1, X_train[cols], y_train)"
  },
  {
    "objectID": "posts/blog-4/Untitled4.html",
    "href": "posts/blog-4/Untitled4.html",
    "title": "Auditing Allocative Bias",
    "section": "",
    "text": "from folktables import ACSDataSource, ACSEmployment, BasicProblem, adult_filter\nimport numpy as np\n\nSTATE = \"AL\"\n\ndata_source = ACSDataSource(survey_year='2018', \n                            horizon='1-Year', \n                            survey='person')\n\nacs_data = data_source.get_data(states=[STATE], download=True)\n\npossible_features=['AGEP', 'SCHL', 'MAR', 'RELP', 'DIS', 'ESP', 'CIT', 'MIG', 'MIL', 'ANC', 'NATIVITY', 'DEAR', 'DEYE', 'DREM', 'SEX', 'RAC1P', 'ESR']\nacs_data[possible_features].head()\n\n\n\n\n\n\n\n\nAGEP\nSCHL\nMAR\nRELP\nDIS\nESP\nCIT\nMIG\nMIL\nANC\nNATIVITY\nDEAR\nDEYE\nDREM\nSEX\nRAC1P\nESR\n\n\n\n\n0\n19\n18.0\n5\n17\n2\nNaN\n1\n3.0\n4.0\n1\n1\n2\n2\n2.0\n2\n1\n6.0\n\n\n1\n18\n18.0\n5\n17\n2\nNaN\n1\n3.0\n4.0\n1\n1\n2\n2\n2.0\n2\n2\n6.0\n\n\n2\n53\n17.0\n5\n16\n1\nNaN\n1\n1.0\n4.0\n2\n1\n2\n2\n1.0\n1\n1\n6.0\n\n\n3\n28\n19.0\n5\n16\n2\nNaN\n1\n1.0\n2.0\n1\n1\n2\n2\n2.0\n1\n1\n6.0\n\n\n4\n25\n12.0\n5\n16\n1\nNaN\n1\n3.0\n4.0\n1\n1\n2\n2\n1.0\n2\n1\n6.0\n\n\n\n\n\n\n\n\nfeatures_to_use = [f for f in possible_features if f not in [\"ESR\", \"RAC1P\"]]\n\nEmploymentProblem = BasicProblem(\n    features=features_to_use,\n    target='ESR',\n    target_transform=lambda x: x == 1,\n    group='RAC1P',\n    preprocess=lambda x: x,\n    postprocess=lambda x: np.nan_to_num(x, -1),\n)\n\nfeatures, label, group = EmploymentProblem.df_to_numpy(acs_data)\n\nfor obj in [features, label, group]:\n  print(obj.shape)\n\nfrom sklearn.model_selection import train_test_split\nX_train, X_test, y_train, y_test, group_train, group_test = train_test_split(\n    features, label, group, test_size=0.2, random_state=0)\n\nfrom sklearn.linear_model import LogisticRegression\nfrom sklearn.pipeline import make_pipeline\nfrom sklearn.preprocessing import StandardScaler\nfrom sklearn.metrics import confusion_matrix\n\nmodel = make_pipeline(StandardScaler(), LogisticRegression())\nmodel.fit(X_train, y_train)\n\ny_hat = model.predict(X_test)\n\n(47777, 15)\n(47777,)\n(47777,)\n\n\n\n(y_hat == y_test).mean()\n(y_hat == y_test)[group_test == 1].mean()\n(y_hat == y_test)[group_test == 2].mean()\n\n0.7838630806845965"
  },
  {
    "objectID": "posts/blog-4/Untitled4.html#overall-measures",
    "href": "posts/blog-4/Untitled4.html#overall-measures",
    "title": "Auditing Allocative Bias",
    "section": "Overall Measures",
    "text": "Overall Measures\nWhat is the overall accuracy of your model?\nWhat is the positive predictive value (PPV) of your model?\nWhat are the overall false negative and false positive rates (FNR and FPR) for your model?\n\nfrom sklearn.metrics import confusion_matrix\n\n\ny_hat = model.predict(X_test)\noverall_accuracy=(y_hat == y_test).mean()\n\nprint(\"the overall accuracy of this model is \"+str(overall_accuracy*100)+\"%\")\n\n### What are the overall false negative and false positive rates (FNR and FPR) for your model?\ntn, fp, fn, tp = confusion_matrix(y_test, model.predict(X_test)).ravel()\n\nppv= tp/(fp+tp)\nprint(\"the PPV of my model is \"+str(ppv))\n\nfnr=fn / (fn + tp)\nfpr=fp / (fp + tn)\n\nprint(\"the FNR of my model is \"+str(fnr))\nprint(\"the FPR of my model is \"+str(fpr))\n\nthe overall accuracy of this model is 82.86663502610347%\nthe PPV of my model is 0.5755968169761273\nthe FNR of my model is 0.48086124401913877\nthe FPR of my model is 0.09473060982830077\n\n\nOur model appears to have a fairly high accuracy. However, as we can observe, the PPV for our model is actually low, and the FNR is quite high. The PPV predicts the probability of a value we predict to be positive actually being positive. FNR represents the proportion of false negatives out of all the individuals who truly have a positive outcome."
  },
  {
    "objectID": "posts/blog-4/Untitled4.html#by-group-measures",
    "href": "posts/blog-4/Untitled4.html#by-group-measures",
    "title": "Auditing Allocative Bias",
    "section": "By-Group Measures",
    "text": "By-Group Measures\nWhat is the accuracy of your model on each subgroup?\nWhat is the PPV of your model on each subgroup?\nWhat are the FNR and FPR on each subgroup?\nLet us now divide our data based on sex, and assess the accuracy, FNR, PPV and FPR for both sexes\n\naccuracy_men=(y_hat == y_test)[group_test == 1].mean()\naccuracy_women=(y_hat == y_test)[group_test == 2].mean()\n\nprint(\"the accuracy for men is \"+str(accuracy_men))\nprint(\"the accuracy for women is \"+str(accuracy_women))\n\ntn_w, fp_w, fn_w, tp_w = confusion_matrix(y_test[group_test == 2], model.predict(X_test[group_test == 2])).ravel()\n#tn, fp, fn, tp = confusion_matrix(y_test, model.predict(X_test)).ravel()\n\nppv_w=tp_w /(fp_w + tp_w)\nfnr_w=fn_w / (fn_w + tp_w)\nfpr_w=fp_w / (fp_w + tn_w)\n\nprint(\"the PPV for women is \"+str(ppv_w))\nprint(\"the FNR for women is \"+str(fnr_w))\nprint(\"the FPR for women is \"+str(fpr_w))\n\ntn_m, fp_m, fn_m, tp_m = confusion_matrix(y_test[group_test == 1], model.predict(X_test[group_test == 1])).ravel()\n\n\nppv_m=tp_m /(fp_m + tp_m)\nfnr_m=fn_m / (fn_m + tp_m)\nfpr_m=fp_m / (fp_m + tn_m)\n\nprint(\"the PPV for men is \"+str(ppv_m))\nprint(\"the FNR for men is \"+str(fnr_m))\nprint(\"the FPR for men is \"+str(fpr_m))\n\nthe accuracy for men is 0.806472284524191\nthe accuracy for women is 0.8503125\nthe PPV for women is 0.3304157549234136\nthe FNR for women is 0.5339506172839507\nthe FPR for women is 0.10639777468706536\nthe PPV for men is 0.7418397626112759\nthe FNR for men is 0.46236559139784944\nthe FPR for men is 0.07941579187585578\n\n\nwe can observe the following:\nAccuracy: Women have a slightly higher accuracy than men.\nPPV: Men have a significantly higher PPV compared to women, indicating that when men are predicted as positive, they are more likely to truly have the positive outcome.\nFNR: Women have a higher FNR than men, suggesting that women are more likely to be falsely classified as negative (not having the positive outcome) when they actually have it.\nFPR: Women have a higher FPR than men, indicating that women are more likely to be falsely classified as positive (having the positive outcome) when they don't actually have it."
  },
  {
    "objectID": "posts/blog-4/Untitled4.html#bias-measures",
    "href": "posts/blog-4/Untitled4.html#bias-measures",
    "title": "Auditing Allocative Bias",
    "section": "Bias Measures",
    "text": "Bias Measures\nSee Chouldechova (2017) for definitions of these terms. For calibration, you can think of the score as having only two values, 0 and 1.\nIs your model approximately calibrated?\nDoes your model satisfy approximate error rate balance?\nDoes your model satisfy statistical parity?\n\nfrom sklearn.calibration import calibration_curve\n\nprob_pos = model.predict_proba(X_test)[:, 1]\nfraction_of_positives, mean_predicted_value = calibration_curve(y_test, prob_pos, n_bins=10)\n\nplt.plot(mean_predicted_value, fraction_of_positives, label='Calibration Curve')\nplt.plot([0, 1], [0, 1], color=\"#919191\", label='Ideal Calibration')\nplt.xlabel('Mean Predicted Value')\nplt.ylabel('Fraction of Positives')\nplt.title('Calibration Curve')\nplt.legend()\nplt.show()\n\n\n\n\nOur calibration curve appears to be somewhat in line with the ideal calibration line until the 0.75 mean predicted value. However, following this predicted value, it appears as though our model is underconfident. This means that the predicted probabilities are generally lower than the observed probabilities. In other words, the model is less certain about positive instances than it should be.\n\nppv_gap=ppv_w-ppv_m\nfnr_gap=fnr_w-fnr_m\nfpr_gap=fpr_w-fpr_m\n\nprint(\"ppv_gap= \"+str(ppv_gap)+\" fnr_gap=\"+str(fnr_gap)+\" fpr_gap=\"+str(fpr_w))\n\nppv_gap= -0.41142400768786236 fnr_gap=0.07158502588610122 fpr_gap=0.10639777468706536\n\n\nWe do not observe a high level of difference for the false negative and positive rates, suggesting that our model satisfies approximate error rate balance. However, the false negative and positive rates are both higher for women."
  }
]