[
  {
    "objectID": "posts/example-blog-post/index.html",
    "href": "posts/example-blog-post/index.html",
    "title": "Hello Blog",
    "section": "",
    "text": "from source import Perceptron\np = Perceptron()\n\nI did it!!\nnot implemented\nThis is an example of the blog posts that you’ll submit as your primary form of learning demonstration in CSCI 0451. I created this post by modifying the file posts/example-blog-post/index.ipynb in VSCode. You can also use JupyterLab for this editing if you prefer. Finally, it is possible to write blog posts without using notebooks by writing .qmd files, as illustrated here."
  },
  {
    "objectID": "posts/example-blog-post/index.html#math",
    "href": "posts/example-blog-post/index.html#math",
    "title": "Hello Blog",
    "section": "Math",
    "text": "Math\nIn addition to regular text using the Markdown specification, you can also write mathematics, enclosed between dollar signs. The syntax for writing math is very similar to the syntax used in the \\(\\LaTeX\\) markup language. For example, $f(x) \\approx y$ renders to \\(f(x) \\approx y\\). To place complex mathematical expressions on their own lines, use double dollar signs. For example, the expression\n$$\\mathcal{L}(a, b) = \\sum_{i = 1}^n (ax_i + b - y_i)^2$$\nrenders to:\n\\[\\mathcal{L}(a, b) = \\sum_{i = 1}^n (ax_i + b - y_i)^2\\;.\\]\nBehind the scenes, math is powered by the MathJax engine. For more on how to write math, check this handy tutorial and quick reference."
  },
  {
    "objectID": "posts/new-test-post/index.html",
    "href": "posts/new-test-post/index.html",
    "title": "Second Post",
    "section": "",
    "text": "from source import Perceptron\np = Perceptron()\n\nI did it!!\nnot implemented\nThis is an example of the blog posts that you’ll submit as your primary form of learning demonstration in CSCI 0451. I created this post by modifying the file posts/example-blog-post/index.ipynb in VSCode. You can also use JupyterLab for this editing if you prefer. Finally, it is possible to write blog posts without using notebooks by writing .qmd files, as illustrated here."
  },
  {
    "objectID": "posts/new-test-post/index.html#math",
    "href": "posts/new-test-post/index.html#math",
    "title": "Second Post",
    "section": "Math",
    "text": "Math\nIn addition to regular text using the Markdown specification, you can also write mathematics, enclosed between dollar signs. The syntax for writing math is very similar to the syntax used in the \\(\\LaTeX\\) markup language. For example, $f(x) \\approx y$ renders to \\(f(x) \\approx y\\). To place complex mathematical expressions on their own lines, use double dollar signs. For example, the expression\n$$\\mathcal{L}(a, b) = \\sum_{i = 1}^n (ax_i + b - y_i)^2$$\nrenders to:\n\\[\\mathcal{L}(a, b) = \\sum_{i = 1}^n (ax_i + b - y_i)^2\\;.\\]\nBehind the scenes, math is powered by the MathJax engine. For more on how to write math, check this handy tutorial and quick reference."
  },
  {
    "objectID": "index.html",
    "href": "index.html",
    "title": "My Awesome CSCI 0451 Blog",
    "section": "",
    "text": "Experiments\n\n\n\n\n\n\n\n\n\n\n \n\n\n\n\n  \n\n\n\n\nPerceptron\n\n\n\n\n\n\n\n\n\n\n \n\n\n\n\n  \n\n\n\n\nLearning from Timnit Gebru\n\n\n\n\n\n\n\n\n\n\n \n\n\n\n\n  \n\n\n\n\nSecond Post\n\n\n\n\n\nA new blog post that I just made!\n\n\n\n\n\n\nMar 10, 2023\n\n\nPhil Chodrow\n\n\n\n\n\n\n  \n\n\n\n\nHello Blog\n\n\n\n\n\nAn example blog post illustrating the key techniques you’ll need to demonstrate your learning in CSCI 0451.\n\n\n\n\n\n\nJan 10, 2023\n\n\nPhil Chodrow\n\n\n\n\n\n\nNo matching items"
  },
  {
    "objectID": "about.html",
    "href": "about.html",
    "title": "About",
    "section": "",
    "text": "About this blog"
  },
  {
    "objectID": "posts/blog-1/blog1.html",
    "href": "posts/blog-1/blog1.html",
    "title": "Perceptron",
    "section": "",
    "text": "import numpy as np\nimport pandas as pd\nimport seaborn as sns\nfrom matplotlib import pyplot as plt\nfrom sklearn.datasets import make_blobs\n\nfrom perceptron import Perceptron\n\nnp.random.seed(12345)\n\nn = 100\np_features = 3\n\nX, y = make_blobs(n_samples = 100, n_features = p_features - 1, centers = [(-1.7, -1.7), (1.7, 1.7)])\n\np = Perceptron()\np.fit(X, y, max_steps=1000)\np.w\nprint(p.history[-10:])\n\nw= np.array([1, 2, 3, 4, 5])\nx= np.array([2, 2, 3, 4, 5])\nb= 1000\n\n\ndef draw_line(w, x_min, x_max):\n  x = np.linspace(x_min, x_max, 101)\n  y = -(w[0]*x + w[2])/w[1]\n  plt.plot(x, y, color = \"black\")\n\nfig = plt.scatter(X[:,0], X[:,1], c = y)\nfig = draw_line(p.w, -2, 2)\n\nxlab = plt.xlabel(\"Feature 1\")\nylab = plt.ylabel(\"Feature 2\")\n\n#print(Perceptron.perceptron_classify(w, b ,x))\n\n#print(Perceptron.fit(w,x))\n\n\nfig = plt.plot(p.history)\nxlab = plt.xlabel(\"Iteration\")\nylab = plt.ylabel(\"Accuracy\")\n\n\n\n\n\nExperiments\nUsing 2d data like the data in the example, if the data is linearly separable then the perceptron algorithm converges to weight vector w describing a separating line (provided that the maximum number of iterations is large enough).\nPlease show visualizations of the data, the separating line, and the evolution of the accuracy over training. It’s also fine for you to use the loss instead of the accuracy if you’d prefer.\n(The two visualizations above show the data with the line of separation and the evolution of the accuracy over time)\nFor 2d data, when the data is not linearly separable, the perceptron algorithm will not settle on a final value of w, but will instead run until the maximum number of iterations is reached, without achieving perfect accuracy.\nPlease show visualizations of the data, the line in the final iteration, and the evolution of the score over training.\n\nimport numpy as np\nimport pandas as pd\nimport seaborn as sns\nfrom matplotlib import pyplot as plt\nfrom sklearn.datasets import make_blobs\n\nfrom perceptron import Perceptron\n\nnp.random.seed(12345)\n\nn = 100\np_features = 3\n\nX, y = make_blobs(n_samples = 100, n_features = p_features - 1, centers =  [(0, 0), (0, 0)])\n\np = Perceptron()\np.fit(X, y, max_steps=1000)\np.w\nprint(p.history[-10:])\n\nw= np.array([1, 2, 3, 4, 5])\nx= np.array([2, 2, 3, 4, 5])\nb= 1000\n\n\ndef draw_line(w, x_min, x_max):\n  x = np.linspace(x_min, x_max, 101)\n  y = -(w[0]*x + w[2])/w[1]\n  plt.plot(x, y, color = \"black\")\n\nfig = plt.scatter(X[:,0], X[:,1], c = y)\nfig = draw_line(p.w, -2, 2)\n\nxlab = plt.xlabel(\"Feature 1\")\nylab = plt.ylabel(\"Feature 2\")\n\n[0.52, 0.54, 0.45, 0.48, 0.48, 0.41, 0.47, 0.48, 0.48, 0.48]\n\n\n\n\n\n\nfig = plt.plot(p.history)\nxlab = plt.xlabel(\"Iteration\")\nylab = plt.ylabel(\"Accuracy\")\n\n\n\n\nThe perceptron algorithm is also able to work in more than 2 dimensions! Show an example of running your algorithm on data with at least 5 features. You don’t need to visualize the data or the separating line, but you should still show the evolution of the score over the training period. Include a comment on whether you believe that the data is linearly separable based on your observation of the score.\n\nimport numpy as np\nimport pandas as pd\nimport seaborn as sns\nfrom matplotlib import pyplot as plt\nfrom sklearn.datasets import make_blobs\n\nfrom perceptron import Perceptron\n\nnp.random.seed(12345)\n\nn = 100\np_features = 5\n\nX, y = make_blobs(n_samples = 100, n_features = p_features - 1, centers = [(8, 8), (-8, -8), (0, 0), (4, 4)])\n\np = Perceptron()\np.fit(X, y, max_steps=50000)\np.w\nprint(p.history[-10:])\n\nw= np.array([1, 2, 3, 4, 5])\nx= np.array([2, 2, 3, 4, 5])\nb= 1000\n\n[0.5, 0.5, 0.5, 0.5, 0.5, 0.5, 0.5, 0.5, 0.5, 0.5]\n\n\nHere is the link to the python file: https://github.com/pwad1/465_blog1/blob/main/perceptron.py"
  },
  {
    "objectID": "posts/blog-timnit-gebru/TimnitGebru.html",
    "href": "posts/blog-timnit-gebru/TimnitGebru.html",
    "title": "Learning from Timnit Gebru",
    "section": "",
    "text": "Introduction\nDr. Timnit Gebru is a computer scientist best known for her substantial work on AI ethics and algorithmic bias. She has also done substantial work on computer vision and natural language processing. She is best known for her research highlighting the biases and limitations of facial recognition technology.\nShe had co-founded the Ethical AI team at Google in 2018. In 2020, her work with Google came to an end due to a dispute regarding a paper on the limitations and biases of natural language processing models co-authored by her. Dr. Gebru claims that her paper was not accepted by Google’s journal due to it not taking AI ethics seriously. Her alleged removal from Google was widely reported in the media as an example of large technology companies silencing voices expressing concern about the nature of their operations.\n\n\nNotes from the lecture\nDr. Gebru is particularly concerned about how facial recognition tools are used, and how they could be used, by law enforcement agencies. Firstly, facial recognition models face data related constraints, especially among racial and ethnic minorities, and individuals that are non cisgender men. These constrains can result in poorer recognition of these minorities, putting these individuals at greater risk of being interrogated or imprisoned without cause. These tools are also less effective in recognizing cultural differences in non-white cultures, due to biases in data.\nShe also argues that the practices used by law enforcement agencies to collect data for these purposes is highly suspect. States, such as Maryland, use extensive level surveillance programs. Law enforcement agencies have also scraped social media sites to find pictures of individuals participating in certain political activities, and have used their facial recognition models to identify these individuals. According to Dr. Gebru, these practices stifle political dissent and limit personal freedom.\nAdditionally, facial recognition tools might not be used by law enforcement agencies in the ways in which these tools were intended to be used. Hence, biases that are rampant in these institutions could be magnified by these technologies. These tools can also be used by authoritarian regimes to maintain control and establish a police state.\nTl;dr: computer vision technologies are expected to magnify biases that already exist within our societies. To prevent this from happening, we need to be more conscious about how diverse our data is, and how are data is being collected. We also need to be conscious about biases within our models and have a sense of who it is benefiting and who it harming.\n\n\nProposed Question:\nThe advancement of computer vision and natural langauge processing models has some obvious benefits and drawbacks. Dr. Gebru’s work does a great job in identifying and studying manners in these models may magnify systemic biases experienced by racial minorities and individuals that are not cisgender men. She is also very convincing in her arguments about how authoritarian regimes may misuse these technologies. However, just as building a model may put certain people at risk, not building a model may also prevent a group of people from realizing certain benefits. How do we assess the opportunity cost of unrealized benefits with the risks posed by machine learning models within the context of ML-related regulation?"
  }
]